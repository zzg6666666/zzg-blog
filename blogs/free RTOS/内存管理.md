---
title: free RTOS 内存管理
date: 2024.3.30
tags:
 - tag1
categories:
 - C语言
---

在free RTOS中，提供了`vPortFree()`和`pvPortMalloc()`进行内管的管理，而在C标准库中，也提供了`malloc()`和`free()`进行内存管理，但是标准库并没有考虑到嵌入式系统中所存在的资源紧缺的情况。free RTOS提供了多种`vPortFree()`和`pvPortMalloc()`，对应不同的情况。

```shell
heap_1.c    分配简单，不能释放内存
heap_2.c    不能合并内存碎片 
heap_3.c    使用标准库进行内存管理
heap_4.c    可以合并内存碎片
heap_5.c    可以管理非连续的内存的heap_4.c
```

## heap_1.c

heap_1.c是最简单的内存管理方法，仅仅涉及内存分配，不能释放内存，只能管理一个静态的堆`ucHeap`，


### 配置

**configSUPPORT_DYNAMIC_ALLOCATION**:是否允许动态内存分配，在所有的heap_x.c中，都应该为1

```c
#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
#endif
```

```c
portBYTE_ALIGNMENT: 		内存对齐的值，取决于平台架构

configTOTAL_HEAP_SIZE:		堆的总大小，可用于动态分配内存的总内存量

configADJUSTED_HEAP_SIZE:	调整后的堆的大小，(可以确保堆的开始地址满足对齐要求?)
```

```c
/* A few bytes might be lost to byte aligning the heap start address. */
//不是很清楚为什么要这样，释放出portBYTE_ALIGNMENT个字节的空间
#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )

/* Allocate the memory for the heap. */
/* Allocate the memory for the heap. */
//是否由应用分配内存
#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
	/* The application writer has already defined the array used for the RTOS
	heap - probably so it can be placed in a special segment or address. */
	//用户自己定义的静态内存
	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#else
	//系统默认定义的内存
	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#endif /* configAPPLICATION_ALLOCATED_HEAP */

/* Index into the ucHeap array. */
static size_t xNextFreeByte = ( size_t ) 0;
```

### pvPortMalloc()

```c
void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	//如果字节对齐的单位不是1，进行字节对齐
	#if( portBYTE_ALIGNMENT != 1 )
	{
		//对数据进行对齐的操作，根据`portBYTE_ALIGNMENT`的值，`portBYTE_ALIGNMENT_MASK`也有不同的值。
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )/*相比xWantedSize % portBYTE_ALIGNMENT_MASK更快*/
		{
			/*
			 Byte alignment required. 
			 将xWantedSize按照portBYTE_ALIGNMENT进行强制对齐，让xWantedSize是portBYTE_ALIGNMENT的倍数
			 */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	//挂起所有任务
	vTaskSuspendAll();
	{	//初始化静态变量
		if( pucAlignedHeap == NULL )
		{	
			/*
			&ucHeap[ portBYTE_ALIGNMENT ]，获取堆数组ucHeap[ portBYTE_ALIGNMENT ]第portBYTE_ALIGNMENT个字节的地址，
			跳过一定数量的字节，使得堆的地址满足对齐要求
			~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ):创造一个掩码，用于清除指针的低位
			这行代码，让pucAlignedHeap的地址在ucHeap[0] 和 cHeap[ portBYTE_ALIGNMENT ]之间，同时实现了字节对齐，很精妙的代码
			*/
			/* Ensure the heap starts on a correctly aligned boundary. 在分配pucAlignedHeap的地址时，确保堆的开始地址满足对齐要求*/
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		/*检查空余内存和需要的内存大小没有超过可使用的内存空间*/
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
		/* Check for overflow.检查有没有溢出，剩余的内存和需要的内存长度大于size_t的长度将会导致溢出 */
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)
		{
			/* Return the next free byte then increment the index past this
			block. */
			/*此次分配的内存地址*/
			pvReturn = pucAlignedHeap + xNextFreeByte;
			/*xNextFreeByte增加此次分配的内存空间*/
			xNextFreeByte += xWantedSize;
		}

		//do nothing
		traceMALLOC( pvReturn, xWantedSize );
	}
	/*恢复任务*/
	( void ) xTaskResumeAll();

	//分配失败的处理
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
}
```

## 源代码
```c
#include <stdlib.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
all the API functions to use the MPU wrappers.  That should only be done when
task.h is included from an application file. */
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE

#include "FreeRTOS.h"
#include "task.h"

#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

#if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
#endif

/* A few bytes might be lost to byte aligning the heap start address. */
#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )

/* Allocate the memory for the heap. */
/* Allocate the memory for the heap. */
#if( configAPPLICATION_ALLOCATED_HEAP == 1 )
	/* The application writer has already defined the array used for the RTOS
	heap - probably so it can be placed in a special segment or address. */
	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#else
	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#endif /* configAPPLICATION_ALLOCATED_HEAP */

/* Index into the ucHeap array. */
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
	{
		if( pucAlignedHeap == NULL )
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
		
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
```